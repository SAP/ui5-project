import logger from "@ui5/logger";
const log = logger.getLogger("build:helpers:composeProjectList");

/**
 * Creates an object containing the flattened project dependency tree. Each dependency is defined as an object key while
 * its value is an array of all of its transitive dependencies.
 *
 * @param {@ui5/project/graph/ProjectGraph} graph
 * @returns {Promise<Object<string, string[]>>} A promise resolving to an object with dependency names as
 * 												key and each with an array of its transitive dependencies as value
 */
async function getFlattenedDependencyTree(graph) {
	const dependencyMap = Object.create(null);
	const rootName = graph.getRoot().getName();

	await graph.traverseDepthFirst(({project, getDependencies}) => {
		if (project.getName() === rootName) {
			// Skip root project
			return;
		}
		const projectDeps = [];
		getDependencies().forEach((dep) => {
			const depName = dep.getName();
			projectDeps.push(depName);
			if (dependencyMap[depName]) {
				projectDeps.push(...dependencyMap[depName]);
			}
		});
		dependencyMap[project.getName()] = projectDeps;
	});
	return dependencyMap;
}

/**
 * Creates dependency lists for 'includedDependencies' and 'excludedDependencies'. Regular expressions are directly
 * applied to a list of all project dependencies so that they don't need to be evaluated in later processing steps.
 * Generally, includes are handled with a higher priority than excludes. Additionally, operations for processing
 * transitive dependencies are handled with a lower priority than explicitly mentioned dependencies. The default
 * dependencies set in the build settings are appended in the end.
 *
 * The priority of the various dependency lists is applied in the following order, but note that a later list can't
 * overrule earlier ones:
 * <ol>
 *   <li>includeDependency, includeDependencyRegExp</li>
 *   <li>excludeDependency, excludeDependencyRegExp</li>
 *   <li>includeDependencyTree</li>
 *   <li>excludeDependencyTree</li>
 *   <li>defaultIncludeDependency, defaultIncludeDependencyRegExp, defaultIncludeDependencyTree</li>
 * </ol>
 *
 * @param {object} graph Project tree as generated by the
 *   [@ui5/project/normalizer]{@link @ui5/project/normalizer}
 * @param {object} parameters Parameters
 * @param {boolean} parameters.includeAllDependencies Whether all dependencies should be part of the build result
 *	 This has the lowest priority and basically includes all remaining (not excluded) projects as include
 * @param {string[]} parameters.includeDependency The dependencies to be considered in 'includedDependencies'; the
 *   "*" character can be used as wildcard for all dependencies and is an alias for the CLI option "--all"
 * @param {string[]} parameters.includeDependencyRegExp Strings which are interpreted as regular expressions
 *   to describe the selection of dependencies to be considered in 'includedDependencies'
 * @param {string[]} parameters.includeDependencyTree The dependencies to be considered in 'includedDependencies';
 *   transitive dependencies are also appended
 * @param {string[]} parameters.excludeDependency The dependencies to be considered in 'excludedDependencies'
 * @param {string[]} parameters.excludeDependencyRegExp Strings which are interpreted as regular expressions
 *   to describe the selection of dependencies to be considered in 'excludedDependencies'
 * @param {string[]} parameters.excludeDependencyTree The dependencies to be considered in 'excludedDependencies';
 *   transitive dependencies are also appended
 * @param {string[]} parameters.defaultIncludeDependency Same as 'includeDependency' parameter; used for build
 *   settings
 * @param {string[]} parameters.defaultIncludeDependencyRegExp Same as 'includeDependencyRegExp' parameter; used
 *   for build settings
 * @param {string[]} parameters.defaultIncludeDependencyTree Same as 'includeDependencyTree' parameter; used for
 *   build settings
 * @returns {{includedDependencies:string[],excludedDependencies:string[]}} An object containing the
 *   'includedDependencies' and 'excludedDependencies'
 */
async function createDependencyLists(graph, {
	includeAllDependencies = false,
	includeDependency = [], includeDependencyRegExp = [], includeDependencyTree = [],
	excludeDependency = [], excludeDependencyRegExp = [], excludeDependencyTree = [],
	defaultIncludeDependency = [], defaultIncludeDependencyRegExp = [], defaultIncludeDependencyTree = []
}) {
	if (
		!includeAllDependencies &&
		!includeDependency.length && !includeDependencyRegExp.length && !includeDependencyTree.length &&
		!excludeDependency.length && !excludeDependencyRegExp.length && !excludeDependencyTree.length &&
		!defaultIncludeDependency.length && !defaultIncludeDependencyRegExp.length &&
		!defaultIncludeDependencyTree.length
	) {
		return {includedDependencies: [], excludedDependencies: []};
	}

	const flattenedDependencyTree = await getFlattenedDependencyTree(graph);

	function isExcluded(excludeList, depName) {
		return excludeList && excludeList.has(depName);
	}
	function processDependencies({targetList, dependencies, dependenciesRegExp = [], excludeList, handleSubtree}) {
		if (handleSubtree && dependenciesRegExp.length) {
			throw new Error("dependenciesRegExp can't be combined with handleSubtree:true option");
		}
		dependencies.forEach((depName) => {
			if (depName === "*") {
				targetList.add(depName);
			} else if (flattenedDependencyTree[depName]) {
				if (!isExcluded(excludeList, depName)) {
					targetList.add(depName);
				}
				if (handleSubtree) {
					flattenedDependencyTree[depName].forEach((dep) => {
						if (!isExcluded(excludeList, dep)) {
							targetList.add(dep);
						}
					});
				}
			} else {
				log.warn(
					`Could not find dependency "${depName}" for project ${graph.getRoot().getName()}. ` +
					`Dependency filter is ignored`);
			}
		});
		dependenciesRegExp.map((exp) => new RegExp(exp)).forEach((regExp) => {
			for (const depName in flattenedDependencyTree) {
				if (regExp.test(depName) && !isExcluded(excludeList, depName)) {
					targetList.add(depName);
				}
			}
		});
	}

	const includedDependencies = new Set();
	const excludedDependencies = new Set();

	// add dependencies defined in includeDependency and includeDependencyRegExp to the list of includedDependencies
	processDependencies({
		targetList: includedDependencies,
		dependencies: includeDependency,
		dependenciesRegExp: includeDependencyRegExp
	});
	// add dependencies defined in excludeDependency and excludeDependencyRegExp to the list of excludedDependencies
	processDependencies({
		targetList: excludedDependencies,
		dependencies: excludeDependency,
		dependenciesRegExp: excludeDependencyRegExp
	});
	// add dependencies defined in includeDependencyTree with their transitive dependencies to the list of
	// includedDependencies; due to prioritization only those dependencies are added which are not excluded
	// by excludedDependencies
	processDependencies({
		targetList: includedDependencies,
		dependencies: includeDependencyTree,
		excludeList: excludedDependencies,
		handleSubtree: true
	});
	// add dependencies defined in excludeDependencyTree with their transitive dependencies to the list of
	// excludedDependencies; due to prioritization only those dependencies are added which are not excluded
	// by includedDependencies
	processDependencies({
		targetList: excludedDependencies,
		dependencies: excludeDependencyTree,
		excludeList: includedDependencies,
		handleSubtree: true
	});
	// due to the lower priority only add the dependencies defined in build settings if they are not excluded
	// by any other dependency defined in excludedDependencies
	processDependencies({
		targetList: includedDependencies,
		dependencies: defaultIncludeDependency,
		dependenciesRegExp: defaultIncludeDependencyRegExp,
		excludeList: excludedDependencies
	});
	processDependencies({
		targetList: includedDependencies,
		dependencies: defaultIncludeDependencyTree,
		excludeList: excludedDependencies,
		handleSubtree: true
	});

	if (includeAllDependencies) {
		// If requested, add all dependencies not excluded to include set
		Object.keys(flattenedDependencyTree).forEach((depName) => {
			if (!isExcluded(excludedDependencies, depName)) {
				includedDependencies.add(depName);
			}
		});
	}

	return {
		includedDependencies: Array.from(includedDependencies),
		excludedDependencies: Array.from(excludedDependencies)
	};
}

createDependencyLists._getFlattenedDependencyTree = getFlattenedDependencyTree;

export default createDependencyLists;
